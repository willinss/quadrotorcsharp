###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     28/Apr/2012  19:46:16 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\iar\Myproject\42 #
#                    8IIC\src\Sources\C\Component_C\uart.c                    #
#    Command line =  "C:\Documents and Settings\Administrator\iar\Myproject\4 #
#                    28IIC\src\Sources\C\Component_C\uart.c" -D IAR -D        #
#                    TWR_K60N512 -lCN "C:\Documents and                       #
#                    Settings\Administrator\iar\Myproject\428IIC\bin\Ram\List #
#                    \" -lB "C:\Documents and Settings\Administrator\iar\Mypr #
#                    oject\428IIC\bin\Ram\List\" -o "C:\Documents and         #
#                    Settings\Administrator\iar\Myproject\428IIC\bin\Ram\Obj\ #
#                    " --no_cse --no_unroll --no_inline --no_code_motion      #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I "C:\Documents     #
#                    and Settings\Administrator\iar\Myproject\428IIC\src\Sour #
#                    ces\H\" -I "C:\Documents and                             #
#                    Settings\Administrator\iar\Myproject\428IIC\src\Sources\ #
#                    H\Component_H\" -I "C:\Documents and                     #
#                    Settings\Administrator\iar\Myproject\428IIC\src\Sources\ #
#                    H\Frame_H\" -Ol --use_c++_inline                         #
#    List file    =  C:\Documents and Settings\Administrator\iar\Myproject\42 #
#                    8IIC\bin\Ram\List\uart.lst                               #
#    Object file  =  C:\Documents and Settings\Administrator\iar\Myproject\42 #
#                    8IIC\bin\Ram\Obj\uart.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\iar\Myproject\428IIC\src\Sources\C\Component_C\uart.c
      1          //-------------------------------------------------------------------------*
      2          // 文件名: uart.c                                                          *
      3          // 说  明: uart构件源文件                                                  *
      4          //-------------------------------------------------------------------------*
      5          
      6          #include "uart.h"
      7          
      8          //-------------------------------------------------------------------------*
      9          //函数名: uart_init                                                        *
     10          //功  能: 初始化uartx模块。                                                *
     11          //参  数: uartch:串口号                                                    *
     12          //        sysclk:系统总线时钟，以MHz为单位                                 *
     13          //        baud:波特率，如9600，38400等，一般来说，速度越慢，通信越稳       *
     14          //返  回: 无                                                               *
     15          //说  明:                                                                  *
     16          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     17          void uart_init (UART_MemMapPtr uartch, uint32 sysclk, uint32 baud)
     18          {
   \                     uart_init:
   \   00000000   30B4               PUSH     {R4,R5}
     19          	register uint16 sbr, brfa;
     20          	uint8 temp;
     21          
     22          	//使能引脚
     23          	if (uartch == UART0_BASE_PTR)
   \   00000002   ........           LDR.W    R3,??DataTable3  ;; 0x4006a000
   \   00000006   9842               CMP      R0,R3
   \   00000008   0AD1               BNE.N    ??uart_init_0
     24          	{
     25          		//在PTD6上使能UART0_TXD功能
     26          		PORTD_PCR6 = PORT_PCR_MUX(0x3);
   \   0000000A   ........           LDR.W    R3,??DataTable3_1  ;; 0x4004c018
   \   0000000E   4FF44074           MOV      R4,#+768
   \   00000012   1C60               STR      R4,[R3, #+0]
     27          		//在PTD7上使能UART0_RXD
     28          		PORTD_PCR7 = PORT_PCR_MUX(0x3); 
   \   00000014   ........           LDR.W    R3,??DataTable3_2  ;; 0x4004c01c
   \   00000018   4FF44074           MOV      R4,#+768
   \   0000001C   1C60               STR      R4,[R3, #+0]
   \   0000001E   3DE0               B.N      ??uart_init_1
     29          	}else if (uartch == UART1_BASE_PTR)
   \                     ??uart_init_0:
   \   00000020   ........           LDR.W    R3,??DataTable3_3  ;; 0x4006b000
   \   00000024   9842               CMP      R0,R3
   \   00000026   0AD1               BNE.N    ??uart_init_2
     30          	{
     31          		//在PTC4上使能UART1_TXD功能
     32          		PORTC_PCR4 = PORT_PCR_MUX(0x3); 
   \   00000028   ........           LDR.W    R3,??DataTable3_4  ;; 0x4004b010
   \   0000002C   4FF44074           MOV      R4,#+768
   \   00000030   1C60               STR      R4,[R3, #+0]
     33          		
     34          		//在PTC3上使能UART1_RXD
     35          		PORTC_PCR3 = PORT_PCR_MUX(0x3); 
   \   00000032   ........           LDR.W    R3,??DataTable3_5  ;; 0x4004b00c
   \   00000036   4FF44074           MOV      R4,#+768
   \   0000003A   1C60               STR      R4,[R3, #+0]
   \   0000003C   2EE0               B.N      ??uart_init_1
     36          	}else if (uartch == UART2_BASE_PTR)
   \                     ??uart_init_2:
   \   0000003E   ....               LDR.N    R3,??DataTable3_6  ;; 0x4006c000
   \   00000040   9842               CMP      R0,R3
   \   00000042   08D1               BNE.N    ??uart_init_3
     37          	{
     38          		//在PTD3上使能UART2_TXD功能
     39          		PORTD_PCR3 = PORT_PCR_MUX(0x3); 
   \   00000044   ....               LDR.N    R3,??DataTable3_7  ;; 0x4004c00c
   \   00000046   4FF44074           MOV      R4,#+768
   \   0000004A   1C60               STR      R4,[R3, #+0]
     40          		//在PTD2上使能UART2_RXD
     41          		PORTD_PCR2 = PORT_PCR_MUX(0x3); 
   \   0000004C   ....               LDR.N    R3,??DataTable3_8  ;; 0x4004c008
   \   0000004E   4FF44074           MOV      R4,#+768
   \   00000052   1C60               STR      R4,[R3, #+0]
   \   00000054   22E0               B.N      ??uart_init_1
     42          	}else if (uartch == UART3_BASE_PTR)
   \                     ??uart_init_3:
   \   00000056   ....               LDR.N    R3,??DataTable3_9  ;; 0x4006d000
   \   00000058   9842               CMP      R0,R3
   \   0000005A   08D1               BNE.N    ??uart_init_4
     43          	{
     44          		//在PTC17上使能UART3_TXD功能
     45          		PORTC_PCR17 = PORT_PCR_MUX(0x3); 
   \   0000005C   ....               LDR.N    R3,??DataTable3_10  ;; 0x4004b044
   \   0000005E   4FF44074           MOV      R4,#+768
   \   00000062   1C60               STR      R4,[R3, #+0]
     46          		//在PTC16上使能UART3_RXD
     47          		PORTC_PCR16 = PORT_PCR_MUX(0x3); 
   \   00000064   ....               LDR.N    R3,??DataTable3_11  ;; 0x4004b040
   \   00000066   4FF44074           MOV      R4,#+768
   \   0000006A   1C60               STR      R4,[R3, #+0]
   \   0000006C   16E0               B.N      ??uart_init_1
     48          	}else if (uartch == UART4_BASE_PTR)
   \                     ??uart_init_4:
   \   0000006E   ....               LDR.N    R3,??DataTable3_12  ;; 0x400ea000
   \   00000070   9842               CMP      R0,R3
   \   00000072   08D1               BNE.N    ??uart_init_5
     49          	{
     50          		//在PTE24上使能UART4_TXD功能
     51          		PORTE_PCR24 = PORT_PCR_MUX(0x3); 
   \   00000074   ....               LDR.N    R3,??DataTable3_13  ;; 0x4004d060
   \   00000076   4FF44074           MOV      R4,#+768
   \   0000007A   1C60               STR      R4,[R3, #+0]
     52          		//在PTE25上使能UART4_RXD
     53          		PORTE_PCR25 = PORT_PCR_MUX(0x3); 
   \   0000007C   ....               LDR.N    R3,??DataTable3_14  ;; 0x4004d064
   \   0000007E   4FF44074           MOV      R4,#+768
   \   00000082   1C60               STR      R4,[R3, #+0]
   \   00000084   0AE0               B.N      ??uart_init_1
     54          	}else if (uartch == UART5_BASE_PTR)
   \                     ??uart_init_5:
   \   00000086   ....               LDR.N    R3,??DataTable3_15  ;; 0x400eb000
   \   00000088   9842               CMP      R0,R3
   \   0000008A   07D1               BNE.N    ??uart_init_1
     55          	{
     56          		//在PTE8上使能UART5_TXD功能
     57          		PORTE_PCR8 = PORT_PCR_MUX(0x3); 
   \   0000008C   ....               LDR.N    R3,??DataTable3_16  ;; 0x4004d020
   \   0000008E   4FF44074           MOV      R4,#+768
   \   00000092   1C60               STR      R4,[R3, #+0]
     58          		//在PTE9上使能UART5_RXD
     59          		PORTE_PCR9 = PORT_PCR_MUX(0x3); 
   \   00000094   ....               LDR.N    R3,??DataTable3_17  ;; 0x4004d024
   \   00000096   4FF44074           MOV      R4,#+768
   \   0000009A   1C60               STR      R4,[R3, #+0]
     60          	}
     61          	 
     62          	//使能串口时钟    
     63          	if(uartch == UART0_BASE_PTR)
   \                     ??uart_init_1:
   \   0000009C   ....               LDR.N    R3,??DataTable3  ;; 0x4006a000
   \   0000009E   9842               CMP      R0,R3
   \   000000A0   06D1               BNE.N    ??uart_init_6
     64          		SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
   \   000000A2   ....               LDR.N    R3,??DataTable3_18  ;; 0x40048034
   \   000000A4   1B68               LDR      R3,[R3, #+0]
   \   000000A6   53F48063           ORRS     R3,R3,#0x400
   \   000000AA   ....               LDR.N    R4,??DataTable3_18  ;; 0x40048034
   \   000000AC   2360               STR      R3,[R4, #+0]
   \   000000AE   2DE0               B.N      ??uart_init_7
     65          	else
     66          		if (uartch == UART1_BASE_PTR)
   \                     ??uart_init_6:
   \   000000B0   ....               LDR.N    R3,??DataTable3_3  ;; 0x4006b000
   \   000000B2   9842               CMP      R0,R3
   \   000000B4   06D1               BNE.N    ??uart_init_8
     67          			SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   000000B6   ....               LDR.N    R3,??DataTable3_18  ;; 0x40048034
   \   000000B8   1B68               LDR      R3,[R3, #+0]
   \   000000BA   53F40063           ORRS     R3,R3,#0x800
   \   000000BE   ....               LDR.N    R4,??DataTable3_18  ;; 0x40048034
   \   000000C0   2360               STR      R3,[R4, #+0]
   \   000000C2   23E0               B.N      ??uart_init_7
     68          		else
     69          			if (uartch == UART2_BASE_PTR)
   \                     ??uart_init_8:
   \   000000C4   ....               LDR.N    R3,??DataTable3_6  ;; 0x4006c000
   \   000000C6   9842               CMP      R0,R3
   \   000000C8   06D1               BNE.N    ??uart_init_9
     70          				SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   000000CA   ....               LDR.N    R3,??DataTable3_18  ;; 0x40048034
   \   000000CC   1B68               LDR      R3,[R3, #+0]
   \   000000CE   53F48053           ORRS     R3,R3,#0x1000
   \   000000D2   ....               LDR.N    R4,??DataTable3_18  ;; 0x40048034
   \   000000D4   2360               STR      R3,[R4, #+0]
   \   000000D6   19E0               B.N      ??uart_init_7
     71          			else
     72          				if(uartch == UART3_BASE_PTR)
   \                     ??uart_init_9:
   \   000000D8   ....               LDR.N    R3,??DataTable3_9  ;; 0x4006d000
   \   000000DA   9842               CMP      R0,R3
   \   000000DC   06D1               BNE.N    ??uart_init_10
     73          					SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   000000DE   ....               LDR.N    R3,??DataTable3_18  ;; 0x40048034
   \   000000E0   1B68               LDR      R3,[R3, #+0]
   \   000000E2   53F40053           ORRS     R3,R3,#0x2000
   \   000000E6   ....               LDR.N    R4,??DataTable3_18  ;; 0x40048034
   \   000000E8   2360               STR      R3,[R4, #+0]
   \   000000EA   0FE0               B.N      ??uart_init_7
     74          				else
     75          					if(uartch == UART4_BASE_PTR)
   \                     ??uart_init_10:
   \   000000EC   ....               LDR.N    R3,??DataTable3_12  ;; 0x400ea000
   \   000000EE   9842               CMP      R0,R3
   \   000000F0   06D1               BNE.N    ??uart_init_11
     76          						SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   000000F2   ....               LDR.N    R3,??DataTable3_19  ;; 0x40048028
   \   000000F4   1B68               LDR      R3,[R3, #+0]
   \   000000F6   53F48063           ORRS     R3,R3,#0x400
   \   000000FA   ....               LDR.N    R4,??DataTable3_19  ;; 0x40048028
   \   000000FC   2360               STR      R3,[R4, #+0]
   \   000000FE   05E0               B.N      ??uart_init_7
     77          					else
     78          						SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \                     ??uart_init_11:
   \   00000100   ....               LDR.N    R3,??DataTable3_19  ;; 0x40048028
   \   00000102   1B68               LDR      R3,[R3, #+0]
   \   00000104   53F40063           ORRS     R3,R3,#0x800
   \   00000108   ....               LDR.N    R4,??DataTable3_19  ;; 0x40048028
   \   0000010A   2360               STR      R3,[R4, #+0]
     79          								
     80          	//禁止发送接受
     81          	UART_C2_REG(uartch) &= ~(UART_C2_TE_MASK
     82          				| UART_C2_RE_MASK );
   \                     ??uart_init_7:
   \   0000010C   C378               LDRB     R3,[R0, #+3]
   \   0000010E   13F0F303           ANDS     R3,R3,#0xF3
   \   00000112   C370               STRB     R3,[R0, #+3]
     83          	
     84          	//配置成8位无校验模式
     85          	UART_C1_REG(uartch) = 0;
   \   00000114   0023               MOVS     R3,#+0
   \   00000116   8370               STRB     R3,[R0, #+2]
     86          	
     87          	//计算波特率，串口0、1使用内核时钟，其它串口使用外设时钟，系统时钟为
     88          	//外设时钟的2倍
     89          	if ((uartch == UART0_BASE_PTR) | (uartch == UART1_BASE_PTR))//
   \   00000118   ....               LDR.N    R3,??DataTable3  ;; 0x4006a000
   \   0000011A   9842               CMP      R0,R3
   \   0000011C   08D0               BEQ.N    ??uart_init_12
   \   0000011E   0023               MOVS     R3,#+0
   \   00000120   ....               LDR.N    R4,??DataTable3_3  ;; 0x4006b000
   \   00000122   A042               CMP      R0,R4
   \   00000124   04D0               BEQ.N    ??uart_init_12
   \   00000126   53F00003           ORRS     R3,R3,#0x0
   \   0000012A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000012C   002B               CMP      R3,#+0
   \   0000012E   00D0               BEQ.N    ??uart_init_13
     90          		sysclk+=sysclk;
   \                     ??uart_init_12:
   \   00000130   4918               ADDS     R1,R1,R1
     91          	
     92          	sbr = (uint16)((sysclk*1000)/(baud * 16));
   \                     ??uart_init_13:
   \   00000132   4FF47A73           MOV      R3,#+1000
   \   00000136   03FB01F3           MUL      R3,R3,R1
   \   0000013A   1401               LSLS     R4,R2,#+4
   \   0000013C   B3FBF4F3           UDIV     R3,R3,R4
     93          	temp = UART_BDH_REG(uartch) & ~(UART_BDH_SBR(0x1F));
   \   00000140   0478               LDRB     R4,[R0, #+0]
   \   00000142   14F0E004           ANDS     R4,R4,#0xE0
     94          	UART_BDH_REG(uartch) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   00000146   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000148   1D0A               LSRS     R5,R3,#+8
   \   0000014A   15F01F05           ANDS     R5,R5,#0x1F
   \   0000014E   2C43               ORRS     R4,R5,R4
   \   00000150   0470               STRB     R4,[R0, #+0]
     95          	UART_BDL_REG(uartch) = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   00000152   4370               STRB     R3,[R0, #+1]
     96          	brfa = (((sysclk*32000)/(baud * 16)) - (sbr * 32));
   \   00000154   4FF4FA44           MOV      R4,#+32000
   \   00000158   6143               MULS     R1,R4,R1
   \   0000015A   1201               LSLS     R2,R2,#+4
   \   0000015C   B1FBF2F1           UDIV     R1,R1,R2
   \   00000160   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000162   B1EB4311           SUBS     R1,R1,R3, LSL #+5
     97          	temp = UART_C4_REG(uartch) & ~(UART_C4_BRFA(0x1F));
   \   00000166   827A               LDRB     R2,[R0, #+10]
   \   00000168   12F0E004           ANDS     R4,R2,#0xE0
     98          	UART_C4_REG(uartch) = temp |  UART_C4_BRFA(brfa);    
   \   0000016C   11F01F01           ANDS     R1,R1,#0x1F
   \   00000170   2143               ORRS     R1,R1,R4
   \   00000172   8172               STRB     R1,[R0, #+10]
     99          	
    100          	//使能发送接受
    101          	UART_C2_REG(uartch) |= (UART_C2_TE_MASK
    102          				| UART_C2_RE_MASK );
   \   00000174   C178               LDRB     R1,[R0, #+3]
   \   00000176   51F00C01           ORRS     R1,R1,#0xC
   \   0000017A   C170               STRB     R1,[R0, #+3]
    103          }
   \   0000017C   30BC               POP      {R4,R5}
   \   0000017E   7047               BX       LR               ;; return
    104          
    105          //-------------------------------------------------------------------------*
    106          //函数名: uart_re1                                                         *
    107          //功  能: 串行接受1个字节                                                  *
    108          //参  数: uartch: 串口号                                                   *
    109          //         ch:    接收到的字节                                             *
    110          //返  回: 成功:1;失败:0                                                    *
    111          //说  明:                                                                  *
    112          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    113          uint8 uart_re1 (UART_MemMapPtr uartch,uint8 *ch)
    114          {
    115              uint32 k;
    116              
    117              for (k = 0; k < 0xfbbb; k++)//有时间限制
   \                     uart_re1:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   00E0               B.N      ??uart_re1_0
   \                     ??uart_re1_1:
   \   00000004   521C               ADDS     R2,R2,#+1
   \                     ??uart_re1_0:
   \   00000006   4FF6BB33           MOVW     R3,#+64443
   \   0000000A   9A42               CMP      R2,R3
   \   0000000C   06D2               BCS.N    ??uart_re1_2
    118          		if((UART_S1_REG(uartch) & UART_S1_RDRF_MASK)!= 0)//判断接收缓冲区是否满
   \   0000000E   0379               LDRB     R3,[R0, #+4]
   \   00000010   9B06               LSLS     R3,R3,#+26
   \   00000012   F7D5               BPL.N    ??uart_re1_1
    119          		{
    120          			*ch = UART_D_REG(uartch);
   \   00000014   C079               LDRB     R0,[R0, #+7]
   \   00000016   0870               STRB     R0,[R1, #+0]
    121          			return 1; 			//接受成功
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   06E0               B.N      ??uart_re1_3
    122          		} 
    123          	if(k>=0xfbbb) 
   \                     ??uart_re1_2:
   \   0000001C   4FF6BB30           MOVW     R0,#+64443
   \   00000020   8242               CMP      R2,R0
   \   00000022   01D3               BCC.N    ??uart_re1_4
    124          	{
    125          		return 0;			//接受失败
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   00E0               B.N      ??uart_re1_3
    126          	} 
    127              return 0;
   \                     ??uart_re1_4:
   \   00000028   0020               MOVS     R0,#+0
   \                     ??uart_re1_3:
   \   0000002A   7047               BX       LR               ;; return
    128          }
    129          
    130          //-------------------------------------------------------------------------*
    131          //函数名: uart_send1                                                       *
    132          //功  能: 串行发送1个字节                                                  *
    133          //参  数: uartch: 串口号                                                   *
    134          //         ch:    要发送的字节                                             *
    135          //返  回: 无                                                               *
    136          //说  明:                                                                  *
    137          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    138          void uart_send1 (UART_MemMapPtr uartch, uint8 ch)
    139          {
    140              //等待发送缓冲区空
    141              while(!(UART_S1_REG(uartch) & UART_S1_TDRE_MASK));
   \                     uart_send1:
   \                     ??uart_send1_0:
   \   00000000   0279               LDRB     R2,[R0, #+4]
   \   00000002   1206               LSLS     R2,R2,#+24
   \   00000004   FCD5               BPL.N    ??uart_send1_0
    142              //发送数据
    143              UART_D_REG(uartch) = (uint8)ch;
   \   00000006   C171               STRB     R1,[R0, #+7]
    144           }
   \   00000008   7047               BX       LR               ;; return
    145          
    146          //-------------------------------------------------------------------------*
    147          //函数名: uart_reN                                                         *
    148          //功  能: 串行 接收n个字节                                                 *
    149          //参  数: uartch: 串口号                                                   *
    150          //        buff: 接收缓冲区                                                 *
    151          //		  len:接收长度                                             *
    152          //返  回: 1:成功;0:失败                                                    *
    153          //说  明:                                                                  *
    154          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    155          uint8 uart_reN (UART_MemMapPtr uartch ,uint8* buff,uint16 len)
    156          {
   \                     uart_reN:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    157              uint16 m=0; 
   \   00000008   0027               MOVS     R7,#+0
   \   0000000A   00E0               B.N      ??uart_reN_0
    158              while (m < len)
    159              { 	          
    160            	    if(0==uart_re1(uartch,&buff[m]))
    161            	    	return 0;  //接收失败
    162            	    else m++;
   \                     ??uart_reN_1:
   \   0000000C   7F1C               ADDS     R7,R7,#+1
   \                     ??uart_reN_0:
   \   0000000E   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000012   B742               CMP      R7,R6
   \   00000014   08D2               BCS.N    ??uart_reN_2
   \   00000016   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000018   7919               ADDS     R1,R7,R5
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       uart_re1
   \   00000020   0028               CMP      R0,#+0
   \   00000022   F3D1               BNE.N    ??uart_reN_1
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   00E0               B.N      ??uart_reN_3
    163              } 
    164              
    165              return 1;          //接收成功
   \                     ??uart_reN_2:
   \   00000028   0120               MOVS     R0,#+1
   \                     ??uart_reN_3:
   \   0000002A   F2BD               POP      {R1,R4-R7,PC}    ;; return
    166              
    167          }
    168          
    169          //-------------------------------------------------------------------------*
    170          //函数名: uart_sendN                                                       *
    171          //功  能: 串行 接收n个字节                                                 *
    172          //参  数: uartch: 串口号                                                   *
    173          //        buff: 发送缓冲区                                                 *
    174          //		  len:发送长度                                             *
    175          //返  回: 无                                                               *
    176          //说  明:                                                                  *
    177          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    178          void uart_sendN (UART_MemMapPtr uartch ,uint8* buff,uint16 len)
    179          {
   \                     uart_sendN:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    180              int i;
    181          	for(i=0;i<len;i++)
   \   00000008   0027               MOVS     R7,#+0
   \   0000000A   04E0               B.N      ??uart_sendN_0
    182              {
    183          		uart_send1(uartch,buff[i]);
   \                     ??uart_sendN_1:
   \   0000000C   795D               LDRB     R1,[R7, R5]
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       uart_send1
    184              }
   \   00000014   7F1C               ADDS     R7,R7,#+1
   \                     ??uart_sendN_0:
   \   00000016   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   B742               CMP      R7,R6
   \   0000001A   F7DB               BLT.N    ??uart_sendN_1
    185          }
   \   0000001C   F1BD               POP      {R0,R4-R7,PC}    ;; return
    186          
    187          //-------------------------------------------------------------------------*
    188          //函数名: enableuartreint                                                  *
    189          //功  能: 开串口接收中断                                                   *
    190          //参  数: uartch: 串口号                                                   *
    191          //        irqno: 对应irq号                                                 *
    192          //返  回: 无                                                               *
    193          //说  明:                                                                  *
    194          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    195          void enableuartreint(UART_MemMapPtr uartch,uint8 irqno)
    196          {
   \                     enableuartreint:
   \   00000000   80B5               PUSH     {R7,LR}
    197          	UART_C2_REG(uartch)|=UART_C2_RIE_MASK;   //开放UART接收中断
   \   00000002   C278               LDRB     R2,[R0, #+3]
   \   00000004   52F02002           ORRS     R2,R2,#0x20
   \   00000008   C270               STRB     R2,[R0, #+3]
    198          	enable_irq(irqno);			 //开接收引脚的IRQ中断
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0800               MOVS     R0,R1
   \   0000000E   ........           BL       enable_irq
    199          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
    200          
    201          //-------------------------------------------------------------------------*
    202          //函数名: disableuartreint                                                 *
    203          //功  能: 关串口接收中断                                                   *
    204          //参  数: uartch: 串口号                                                   *
    205          //        irqno: 对应irq号                                                 *
    206          //返  回: 无                                                               *
    207          //说  明:                                                                  *
    208          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    209          void disableuartreint(UART_MemMapPtr uartch,uint8 irqno)
    210          {
   \                     disableuartreint:
   \   00000000   80B5               PUSH     {R7,LR}
    211          	UART_C2_REG(uartch)&=~UART_C2_RIE_MASK;   //禁止UART接收中断
   \   00000002   C278               LDRB     R2,[R0, #+3]
   \   00000004   12F0DF02           ANDS     R2,R2,#0xDF
   \   00000008   C270               STRB     R2,[R0, #+3]
    212          	disable_irq(irqno);			  //关接收引脚的IRQ中断
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0800               MOVS     R0,R1
   \   0000000E   ........           BL       disable_irq
    213          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
    214          

   \                                 In section .text, align 2, keep-with-next
    215          void Asc_send(uint16 data)
    216          {uint8 temp[5] = {0},i = 0;
   \                     Asc_send:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   \   00000002   00A9               ADD      R1,SP,#+0
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0CC1               STM      R1!,{R2,R3}
   \   0000000A   0839               SUBS     R1,R1,#+8
   \   0000000C   0024               MOVS     R4,#+0
    217           temp[0] = data / 10000;
   \   0000000E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   42F21071           MOVW     R1,#+10000
   \   00000014   90FBF1F1           SDIV     R1,R0,R1
   \   00000018   8DF80010           STRB     R1,[SP, #+0]
    218           temp[1] = data / 1000 % 10 ;
   \   0000001C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   4FF47A71           MOV      R1,#+1000
   \   00000022   90FBF1F1           SDIV     R1,R0,R1
   \   00000026   0A22               MOVS     R2,#+10
   \   00000028   91FBF2F3           SDIV     R3,R1,R2
   \   0000002C   02FB1311           MLS      R1,R2,R3,R1
   \   00000030   8DF80110           STRB     R1,[SP, #+1]
    219           temp[2] = data / 100 % 10 ;
   \   00000034   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   6421               MOVS     R1,#+100
   \   00000038   90FBF1F1           SDIV     R1,R0,R1
   \   0000003C   0A22               MOVS     R2,#+10
   \   0000003E   91FBF2F3           SDIV     R3,R1,R2
   \   00000042   02FB1311           MLS      R1,R2,R3,R1
   \   00000046   8DF80210           STRB     R1,[SP, #+2]
    220           temp[3] = data / 10 % 10; 
   \   0000004A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0A21               MOVS     R1,#+10
   \   0000004E   90FBF1F1           SDIV     R1,R0,R1
   \   00000052   0A22               MOVS     R2,#+10
   \   00000054   91FBF2F3           SDIV     R3,R1,R2
   \   00000058   02FB1311           MLS      R1,R2,R3,R1
   \   0000005C   8DF80310           STRB     R1,[SP, #+3]
    221           temp[4] = data  % 10;  
   \   00000060   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0A21               MOVS     R1,#+10
   \   00000064   90FBF1F2           SDIV     R2,R0,R1
   \   00000068   01FB1200           MLS      R0,R1,R2,R0
   \   0000006C   8DF80400           STRB     R0,[SP, #+4]
    222           
    223           for(i=0; i<5; i++)
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   0400               MOVS     R4,R0
   \   00000074   04E0               B.N      ??Asc_send_0
    224            { switch(temp[i])
    225                  { case 0: uart_send1 (UART1, 0x30);continue;
    226                    case 1: uart_send1 (UART1, 0x31);continue;
    227                    case 2: uart_send1 (UART1, 0x32);continue;
    228                    case 3: uart_send1 (UART1, 0x33);continue;
    229                    case 4: uart_send1 (UART1, 0x34);continue;
    230                    case 5: uart_send1 (UART1, 0x35);continue;
    231                    case 6: uart_send1 (UART1, 0x36);continue;
    232                    case 7: uart_send1 (UART1, 0x37);continue;
    233                    case 8: uart_send1 (UART1, 0x38);continue;
    234                    case 9: uart_send1 (UART1, 0x39);continue;
   \                     ??Asc_send_1:
   \   00000076   3921               MOVS     R1,#+57
   \   00000078   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   0000007A   ........           BL       uart_send1
   \                     ??Asc_send_2:
   \   0000007E   641C               ADDS     R4,R4,#+1
   \                     ??Asc_send_0:
   \   00000080   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   052C               CMP      R4,#+5
   \   00000084   40D2               BCS.N    ??Asc_send_3
   \   00000086   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   00A8               ADD      R0,SP,#+0
   \   0000008A   205C               LDRB     R0,[R4, R0]
   \   0000008C   0028               CMP      R0,#+0
   \   0000008E   0ED0               BEQ.N    ??Asc_send_4
   \   00000090   0228               CMP      R0,#+2
   \   00000092   16D0               BEQ.N    ??Asc_send_5
   \   00000094   10D3               BCC.N    ??Asc_send_6
   \   00000096   0428               CMP      R0,#+4
   \   00000098   1DD0               BEQ.N    ??Asc_send_7
   \   0000009A   17D3               BCC.N    ??Asc_send_8
   \   0000009C   0628               CMP      R0,#+6
   \   0000009E   24D0               BEQ.N    ??Asc_send_9
   \   000000A0   1ED3               BCC.N    ??Asc_send_10
   \   000000A2   0828               CMP      R0,#+8
   \   000000A4   2BD0               BEQ.N    ??Asc_send_11
   \   000000A6   25D3               BCC.N    ??Asc_send_12
   \   000000A8   0928               CMP      R0,#+9
   \   000000AA   E4D0               BEQ.N    ??Asc_send_1
   \   000000AC   E7E7               B.N      ??Asc_send_2
   \                     ??Asc_send_4:
   \   000000AE   3021               MOVS     R1,#+48
   \   000000B0   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000B2   ........           BL       uart_send1
   \   000000B6   E2E7               B.N      ??Asc_send_2
   \                     ??Asc_send_6:
   \   000000B8   3121               MOVS     R1,#+49
   \   000000BA   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000BC   ........           BL       uart_send1
   \   000000C0   DDE7               B.N      ??Asc_send_2
   \                     ??Asc_send_5:
   \   000000C2   3221               MOVS     R1,#+50
   \   000000C4   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000C6   ........           BL       uart_send1
   \   000000CA   D8E7               B.N      ??Asc_send_2
   \                     ??Asc_send_8:
   \   000000CC   3321               MOVS     R1,#+51
   \   000000CE   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000D0   ........           BL       uart_send1
   \   000000D4   D3E7               B.N      ??Asc_send_2
   \                     ??Asc_send_7:
   \   000000D6   3421               MOVS     R1,#+52
   \   000000D8   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000DA   ........           BL       uart_send1
   \   000000DE   CEE7               B.N      ??Asc_send_2
   \                     ??Asc_send_10:
   \   000000E0   3521               MOVS     R1,#+53
   \   000000E2   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000E4   ........           BL       uart_send1
   \   000000E8   C9E7               B.N      ??Asc_send_2
   \                     ??Asc_send_9:
   \   000000EA   3621               MOVS     R1,#+54
   \   000000EC   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000EE   ........           BL       uart_send1
   \   000000F2   C4E7               B.N      ??Asc_send_2
   \                     ??Asc_send_12:
   \   000000F4   3721               MOVS     R1,#+55
   \   000000F6   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   000000F8   ........           BL       uart_send1
   \   000000FC   BFE7               B.N      ??Asc_send_2
   \                     ??Asc_send_11:
   \   000000FE   3821               MOVS     R1,#+56
   \   00000100   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   00000102   ........           BL       uart_send1
   \   00000106   BAE7               B.N      ??Asc_send_2
    235                  }
    236            }
    237           //uart_send1 (UART1, '\r');
    238           //uart_send1 (UART1, '\n');
    239          }
   \                     ??Asc_send_3:
   \   00000108   13BD               POP      {R0,R1,R4,PC}    ;; return
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void Send_Enter()
    242          {
   \                     Send_Enter:
   \   00000000   80B5               PUSH     {R7,LR}
    243           uart_send1 (UART1, '\r');
   \   00000002   0D21               MOVS     R1,#+13
   \   00000004   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   00000006   ........           BL       uart_send1
    244           uart_send1 (UART1, '\n');
   \   0000000A   0A21               MOVS     R1,#+10
   \   0000000C   ....               LDR.N    R0,??DataTable3_3  ;; 0x4006b000
   \   0000000E   ........           BL       uart_send1
    245          }
   \   00000012   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   00A00640           DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   18C00440           DC32     0x4004c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   1CC00440           DC32     0x4004c01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   00B00640           DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   10B00440           DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0CB00440           DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   00C00640           DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0CC00440           DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   08C00440           DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   00D00640           DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   44B00440           DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   40B00440           DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   00A00E40           DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   60D00440           DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   64D00440           DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   00B00E40           DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   20D00440           DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   24D00440           DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_18:
   \   00000000   34800440           DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_19:
   \   00000000   28800440           DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
    246          
    247          
    248          
    249          
    250          
    251          
    252          
    253          
    254          
    255          
    256          

   Maximum stack usage in bytes:

     Function         .cstack
     --------         -------
     Asc_send             16
     Send_Enter            8
     disableuartreint      8
     enableuartreint       8
     uart_init             8
     uart_re1              0
     uart_reN             24
     uart_send1            0
     uart_sendN           24


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     uart_init         384
     uart_re1           44
     uart_send1         10
     uart_reN           44
     uart_sendN         30
     enableuartreint    20
     disableuartreint   20
     Asc_send          266
     Send_Enter         20
     ??DataTable3        4
     ??DataTable3_1      4
     ??DataTable3_2      4
     ??DataTable3_3      4
     ??DataTable3_4      4
     ??DataTable3_5      4
     ??DataTable3_6      4
     ??DataTable3_7      4
     ??DataTable3_8      4
     ??DataTable3_9      4
     ??DataTable3_10     4
     ??DataTable3_11     4
     ??DataTable3_12     4
     ??DataTable3_13     4
     ??DataTable3_14     4
     ??DataTable3_15     4
     ??DataTable3_16     4
     ??DataTable3_17     4
     ??DataTable3_18     4
     ??DataTable3_19     4
     ?<Constant {0}>     8

 
 926 bytes in section .text
 
 926 bytes of CODE memory

Errors: none
Warnings: none
