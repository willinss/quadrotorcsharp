###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     03/Aug/2015  09:48:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车( #
#                    改I2C)\src\Sources\C\Component_C\hw_i2c.c                #
#    Command line =  "C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车 #
#                    (改I2C)\src\Sources\C\Component_C\hw_i2c.c" -D IAR -D    #
#                    TWR_K60N512 -lCN "C:\Users\Thinkpad\Desktop\quadrotor150 #
#                    720飞行器跟随小车(改I2C)\bin\Flash\List\" -lB            #
#                    "C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车 #
#                    (改I2C)\bin\Flash\List\" -o                              #
#                    "C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车 #
#                    (改I2C)\bin\Flash\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "E:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\Thinkpad\Desktop\quadrotor150720飞行 #
#                    器跟随小车(改I2C)\src\Sources\H\" -I                     #
#                    "C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车 #
#                    (改I2C)\src\Sources\H\Component_H\" -I                   #
#                    "C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车 #
#                    (改I2C)\src\Sources\H\Frame_H\" -Ol --use_c++_inline     #
#    List file    =  C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车( #
#                    改I2C)\bin\Flash\List\hw_i2c.lst                         #
#    Object file  =  C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车( #
#                    改I2C)\bin\Flash\Obj\hw_i2c.o                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Thinkpad\Desktop\quadrotor150720飞行器跟随小车(改I2C)\src\Sources\C\Component_C\hw_i2c.c
      1          //============================================================================
      2          //文件名称：hw_i2c.h  
      3          //功能概要：uart构件头文件
      4          //版权所有：苏州大学飞思卡尔嵌入式中心(sumcu.suda.edu.cn)
      5          //版本更新：2011-11-17     V1.0       stone    编写了K60的i2c驱动
      6          //============================================================================
      7          
      8          #ifndef __I2C_H__
      9          #define __I2C_H__
     10          	
     11          #include "common.h"
     12          #include "hw_i2c.h"
     13          
     14          
     15          //============================================================================
     16          //函数名称：hw_i2c_init                                                        
     17          //功能概要：初始化IICX模块。                                                
     18          //参数说明：MoudleNum:模块号                                                         
     19          //函数返回：无                                                                  
     20          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     21          void hw_i2c_init(int MoudleNum)
     22          {
   \                     hw_i2c_init:
   \   00000000   0xB580             PUSH     {R7,LR}
     23          	//获取i2c模块基址
     24          	I2C_MemMapPtr num = hw_i2c_get_base_address(MoudleNum);
   \   00000002   0x.... 0x....      BL       hw_i2c_get_base_address
     25          	
     26          	if(num == I2C0)
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40066000
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD11A             BNE.N    ??hw_i2c_init_0
     27          	{
     28          		//打开I2C0模块时钟
     29          		SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK; 
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable2_1  ;; 0x40048034
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable2_1  ;; 0x40048034
   \   0000001C   0x6008             STR      R0,[R1, #+0]
     30          		//配置引脚复用为I2C0功能
     31          		//I2C0 SCL使用PTB0
     32          		//I2C0 SDA使用PTb1
     33          		PORTB_PCR0 = PORT_PCR_MUX(2);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x4004a000
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x6001             STR      R1,[R0, #+0]
     34          		PORTB_PCR1 = PORT_PCR_MUX(2);
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable2_3  ;; 0x4004a004
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x6001             STR      R1,[R0, #+0]
     35          		//设置 MULT 和 ICR   
     36          		//芯片手册推荐设置100K以减小MCU负载
     37          		//k60的MCU总线频率为48M，在总线上分频
     38          		I2C0_F  = 0x19;  //300k  
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable2_4  ;; 0x40066001
   \   00000036   0x2119             MOVS     R1,#+25
   \   00000038   0x7001             STRB     R1,[R0, #+0]
     39          		//使能I2C0，不发送应答信号
     40          		I2C0_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;      
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable2_5  ;; 0x40066002
   \   0000003E   0x2188             MOVS     R1,#+136
   \   00000040   0x7001             STRB     R1,[R0, #+0]
   \   00000042   0xE014             B.N      ??hw_i2c_init_1
     41          	}
     42          	else
     43          	{
     44          		//打开I2C1模块时钟
     45          		SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK; 
   \                     ??hw_i2c_init_0:
   \   00000044   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40048034
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004C   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40048034
   \   0000004E   0x6008             STR      R0,[R1, #+0]
     46          		//配置引脚复用为I2C1功能
     47          		//I2C1 SCL使用PTC10
     48          		//I2C1 SDA使用PTC11
     49          		PORTC_PCR10 = PORT_PCR_MUX(2);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable2_6  ;; 0x4004b028
   \   00000054   0xF44F 0x7100      MOV      R1,#+512
   \   00000058   0x6001             STR      R1,[R0, #+0]
     50          		PORTC_PCR11 = PORT_PCR_MUX(2);
   \   0000005A   0x....             LDR.N    R0,??DataTable2_7  ;; 0x4004b02c
   \   0000005C   0xF44F 0x7100      MOV      R1,#+512
   \   00000060   0x6001             STR      R1,[R0, #+0]
     51          		//设置 MULT 和 ICR   
     52          		//芯片手册推荐设置100K以减小MCU负载
     53          		//k60的MCU总线频率为48M，在总线上分频
     54          		I2C1_F  = 0x19;   //300k 1d = 160 1B = 128 375K  19 = 96  500K
   \   00000062   0x....             LDR.N    R0,??DataTable2_8  ;; 0x40067001
   \   00000064   0x2119             MOVS     R1,#+25
   \   00000066   0x7001             STRB     R1,[R0, #+0]
     55          		//使能I2C1，不发送应答信号
     56          		I2C1_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;      
   \   00000068   0x....             LDR.N    R0,??DataTable2_9  ;; 0x40067002
   \   0000006A   0x2188             MOVS     R1,#+136
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
     57          	}
     58          }
   \                     ??hw_i2c_init_1:
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
     59          
     60          //============================================================================
     61          //函数名称：hw_send_signal                                                        
     62          //功能概要：根据需要产生开始或停止信号   。                                                
     63          //参数说明：         MoudleNum:模块号       
     64          //          Signal: 'S'(Start),产生开始信号      'O'(Over),  产生停止信号               
     65          //函数返回：无                                                                  
     66          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     67          void hw_send_signal(uint8 Signal,int MoudleNum)
     68          {
   \                     hw_send_signal:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
     69          	//获取i2c模块基址
     70          	I2C_MemMapPtr num = hw_i2c_get_base_address(MoudleNum);
   \   00000006   0x.... 0x....      BL       hw_i2c_get_base_address
     71          	
     72          	if(num == I2C0)//模块0
   \   0000000A   0x....             LDR.N    R1,??DataTable2  ;; 0x40066000
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD113             BNE.N    ??hw_send_signal_0
     73          	{
     74          		if (Signal == 'S')    
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C53             CMP      R4,#+83
   \   00000014   0xD106             BNE.N    ??hw_send_signal_1
     75          		{
     76          		  i2c0_Start(); //主机模式选择位MST由0变为1,可以产生开始信号  
   \   00000016   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40066002
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001E   0x....             LDR.N    R1,??DataTable2_5  ;; 0x40066002
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   \   00000022   0xE01F             B.N      ??hw_send_signal_2
     77          		}
     78          		else if (Signal == 'O')
   \                     ??hw_send_signal_1:
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C4F             CMP      R4,#+79
   \   00000028   0xD11C             BNE.N    ??hw_send_signal_2
     79          		{
     80          		  i2c0_Stop();//主机模式选择位MST由1变为0,可以产生停止信号
   \   0000002A   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40066002
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000032   0x....             LDR.N    R1,??DataTable2_5  ;; 0x40066002
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   \   00000036   0xE015             B.N      ??hw_send_signal_2
     81          		}
     82          	}
     83          	else if(num == I2C1)//模块1
   \                     ??hw_send_signal_0:
   \   00000038   0x....             LDR.N    R1,??DataTable2_10  ;; 0x40067000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD112             BNE.N    ??hw_send_signal_2
     84          	{
     85          		if (Signal == 'S')    
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C53             CMP      R4,#+83
   \   00000042   0xD106             BNE.N    ??hw_send_signal_3
     86          		{
     87          		  i2c1_Start(); //主机模式选择位MST由0变为1,可以产生开始信号  
   \   00000044   0x....             LDR.N    R0,??DataTable2_9  ;; 0x40067002
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004C   0x....             LDR.N    R1,??DataTable2_9  ;; 0x40067002
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   \   00000050   0xE008             B.N      ??hw_send_signal_2
     88          		}
     89          		else if (Signal == 'O')
   \                     ??hw_send_signal_3:
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C4F             CMP      R4,#+79
   \   00000056   0xD105             BNE.N    ??hw_send_signal_2
     90          		{
     91          		  i2c1_Stop();//主机模式选择位MST由1变为0,可以产生停止信号
   \   00000058   0x....             LDR.N    R0,??DataTable2_9  ;; 0x40067002
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000060   0x....             LDR.N    R1,??DataTable2_9  ;; 0x40067002
   \   00000062   0x7008             STRB     R0,[R1, #+0]
     92          		}
     93          	}
     94          	        
     95                                                        
     96                
     97          }
   \                     ??hw_send_signal_2:
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
     98          
     99          
    100          
    101          //============================================================================
    102          //函数名称：hw_wait                                                        
    103          //功能概要： 在时限内,循环检测接收应答标志位,或传送完成标志位,判断MCU         
    104          //          是否接收到应答信号或一个字节是否已在总线上传送完毕                                            
    105          //参数说明：         MoudleNum:模块号       
    106          //             x:x = 'A'(Ack),等待应答;x = 'T'(Transmission),等待一个字节        
    107          //                 数据传输完成                   
    108          //函数返回：0:收到应答信号或一个字节传送完毕;
    109          //         1:未收到应答信号或一个 字节没传送完                                                                                                                            
    110          //============================================================================
    111          

   \                                 In section .text, align 2, keep-with-next
    112          uint8 hw_wait(uint8 x,int MoudleNum)
    113          
    114          {
   \                     hw_wait:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
    115              uint16 ErrTime, i;
    116              I2C_MemMapPtr num = hw_i2c_get_base_address(MoudleNum);
   \   00000006   0x.... 0x....      BL       hw_i2c_get_base_address
    117              ErrTime = 255*10;            //定义查询超时时限
   \   0000000A   0xF640 0x11F6      MOVW     R1,#+2550
    118              
    119              
    120              //获取i2c模块基址
    121              
    122              
    123          	for (i = 0;i < ErrTime;i++)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xE000             B.N      ??hw_wait_0
   \                     ??hw_wait_1:
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \                     ??hw_wait_0:
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x428A             CMP      R2,R1
   \   0000001A   0xD213             BCS.N    ??hw_wait_2
    124          	{
    125          		if (x == 'A')           //等待应答信号
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C41             CMP      R4,#+65
   \   00000020   0xD104             BNE.N    ??hw_wait_3
    126          		{
    127          			  if(( I2C_S_REG(num)  & I2C_S_RXAK_MASK)==0)
   \   00000022   0x78C3             LDRB     R3,[R0, #+3]
   \   00000024   0x07DB             LSLS     R3,R3,#+31
   \   00000026   0xD4F4             BMI.N    ??hw_wait_1
    128          				 return 0;      //传送完一个字节后,收到了从机的应答信号               
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE011             B.N      ??hw_wait_4
    129          		}
    130          		else if (x == 'T')      //等待传送完成一个字节信号
   \                     ??hw_wait_3:
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C54             CMP      R4,#+84
   \   00000030   0xD1EF             BNE.N    ??hw_wait_1
    131          		{
    132          			if ((I2C_S_REG(num) & I2C_S_IICIF_MASK) != 0)    
   \   00000032   0x78C3             LDRB     R3,[R0, #+3]
   \   00000034   0x079B             LSLS     R3,R3,#+30
   \   00000036   0xD5EC             BPL.N    ??hw_wait_1
    133          			{
    134          				(I2C_S_REG(num) |=(0 | I2C_S_IICIF_MASK));  //清IICIF标志位
   \   00000038   0x78C1             LDRB     R1,[R0, #+3]
   \   0000003A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000003E   0x70C1             STRB     R1,[R0, #+3]
    135          				return 0;       //成功发送完一个字节
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE005             B.N      ??hw_wait_4
    136          			}       
    137          		}
    138          	}
    139          	if (i >= ErrTime)
   \                     ??hw_wait_2:
   \   00000044   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0x428A             CMP      R2,R1
   \   0000004A   0xD301             BCC.N    ??hw_wait_5
    140          		return 1;               //超时,没有收到应答信号或发送完一个字节   	
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE7FF             B.N      ??hw_wait_4
    141          }
   \                     ??hw_wait_5:
   \                     ??hw_wait_4:
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    142          
    143          
    144          //============================================================================
    145          //函数名称：hw_iic_read1                                                        
    146          //功能概要：从从机读1个字节数据                                            
    147          //参数说明：  MoudleNum:模块号       
    148          //          DeviceAddr:设备地址    
    149          //          AccessAddr:访问地址
    150          //          Data:带回收到的一个字节数据  
    151          //函数返回：为0,成功读一个字节;为1,读一个字节失败  
    152          //函数说明: 内部调用 hw_send_signal,hw_wait  
    153          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    154          uint8 hw_iic_read1(int MoudleNum,uint8 DeviceAddr, uint8 AccessAddr, uint8 *Data)
    155          {      
   \                     hw_iic_read1:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
    156                
    157          	//获取i2c模块基址
    158          	I2C_MemMapPtr num = hw_i2c_get_base_address(MoudleNum);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       hw_i2c_get_base_address
   \   00000012   0x0007             MOVS     R7,R0
    159          	
    160          	I2C_C1_REG(num)     |= 0x10;           //TX = 1,MCU设置为发送模式
   \   00000014   0x78B8             LDRB     R0,[R7, #+2]
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001A   0x70B8             STRB     R0,[R7, #+2]
    161          	hw_send_signal('S',MoudleNum);               //发送开始信号 
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x2053             MOVS     R0,#+83
   \   00000020   0x.... 0x....      BL       hw_send_signal
    162          	I2C_D_REG(num)  = DeviceAddr & 0xfe;   //发送设备地址,并通知从机接收数据
   \   00000024   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000028   0x7138             STRB     R0,[R7, #+4]
    163          	 
    164          	if (hw_wait('T',MoudleNum))                  //等待一个字节数据传送完成  
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x2054             MOVS     R0,#+84
   \   0000002E   0x.... 0x....      BL       hw_wait
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD001             BEQ.N    ??hw_iic_read1_0
    165          	{      
    166          
    167          		return 1;                         //没有传送成功,读一个字节失败   
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE045             B.N      ??hw_iic_read1_1
    168          	}
    169          	if (hw_wait('A',MoudleNum))                 //等待从机应答信号 
   \                     ??hw_iic_read1_0:
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0x2041             MOVS     R0,#+65
   \   0000003E   0x.... 0x....      BL       hw_wait
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD001             BEQ.N    ??hw_iic_read1_2
    170          	{
    171          
    172          		return 1;                         //没有等到应答信号,读一个字节失败 
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE03D             B.N      ??hw_iic_read1_1
    173          	}
    174          	I2C_D_REG(num)  = AccessAddr;        //发送访问地址    
   \                     ??hw_iic_read1_2:
   \   0000004A   0xF887 0x8004      STRB     R8,[R7, #+4]
    175          	if (hw_wait('T',MoudleNum))                //等待一个字节数据传送完成 
   \   0000004E   0x0021             MOVS     R1,R4
   \   00000050   0x2054             MOVS     R0,#+84
   \   00000052   0x.... 0x....      BL       hw_wait
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD001             BEQ.N    ??hw_iic_read1_3
    176          	{
    177          	 
    178          		return 1;                        //没有传送成功,读一个字节失败
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE033             B.N      ??hw_iic_read1_1
    179          	}
    180          	if (hw_wait('A',MoudleNum))                //等待从机应答信号   
   \                     ??hw_iic_read1_3:
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x2041             MOVS     R0,#+65
   \   00000062   0x.... 0x....      BL       hw_wait
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??hw_iic_read1_4
    181          	{
    182          	  
    183          		return 1;                        //没有等到应答信号,读一个字节失败  
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE02B             B.N      ??hw_iic_read1_1
    184          	}
    185          	I2C_C1_REG(num) |= 0x04;//当MCU在主机模 式下，向该位写1将产生一个重新开始信号  
   \                     ??hw_iic_read1_4:
   \   0000006E   0x78B8             LDRB     R0,[R7, #+2]
   \   00000070   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000074   0x70B8             STRB     R0,[R7, #+2]
    186          	I2C_D_REG(num) = DeviceAddr | 0x01; //通知从机改为发送数据    
   \   00000076   0xF055 0x0001      ORRS     R0,R5,#0x1
   \   0000007A   0x7138             STRB     R0,[R7, #+4]
    187          	if (hw_wait('T',MoudleNum))               //等待一个字节数据传送完成  
   \   0000007C   0x0021             MOVS     R1,R4
   \   0000007E   0x2054             MOVS     R0,#+84
   \   00000080   0x.... 0x....      BL       hw_wait
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD001             BEQ.N    ??hw_iic_read1_5
    188          	{
    189          	 
    190          		return 1;                       //没有传送成功,读一个字节失败 
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE01C             B.N      ??hw_iic_read1_1
    191          	}
    192          	if (hw_wait('A',MoudleNum))               //等待从机应答信号  
   \                     ??hw_iic_read1_5:
   \   0000008C   0x0021             MOVS     R1,R4
   \   0000008E   0x2041             MOVS     R0,#+65
   \   00000090   0x.... 0x....      BL       hw_wait
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD001             BEQ.N    ??hw_iic_read1_6
    193          	{
    194          	 
    195          		return 1;                      //没有等到应答信号,读一个字节失败
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE014             B.N      ??hw_iic_read1_1
    196          	}
    197          	I2C_C1_REG(num) &= 0xef;           //TX = 0,MCU设置为接收模式    
   \                     ??hw_iic_read1_6:
   \   0000009C   0x78B8             LDRB     R0,[R7, #+2]
   \   0000009E   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000A2   0x70B8             STRB     R0,[R7, #+2]
    198          	*Data = I2C_D_REG(num);            //读出IIC1D,准备接收数据   
   \   000000A4   0x7938             LDRB     R0,[R7, #+4]
   \   000000A6   0x7030             STRB     R0,[R6, #+0]
    199          	if (hw_wait('T',MoudleNum))              //等待一个字节数据传送完成  
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0x2054             MOVS     R0,#+84
   \   000000AC   0x.... 0x....      BL       hw_wait
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??hw_iic_read1_7
    200          	{  
    201          	 
    202          		return 1;                      //没有传送成功,读一个字节失败  
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xE006             B.N      ??hw_iic_read1_1
    203          	}
    204          	hw_send_signal('O',MoudleNum);           //发送停止信号    
   \                     ??hw_iic_read1_7:
   \   000000B8   0x0021             MOVS     R1,R4
   \   000000BA   0x204F             MOVS     R0,#+79
   \   000000BC   0x.... 0x....      BL       hw_send_signal
    205          	*Data = I2C_D_REG(num);            //读出接收到的一个数据    
   \   000000C0   0x7938             LDRB     R0,[R7, #+4]
   \   000000C2   0x7030             STRB     R0,[R6, #+0]
    206          	
    207          	return 0;                          //正确接收到一个字节数据
   \   000000C4   0x2000             MOVS     R0,#+0
   \                     ??hw_iic_read1_1:
   \   000000C6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    208          	
    209          }
    210          
    211          //============================================================================
    212          //函数名称：hw_iic_write1                                                        
    213          //功能概要：向从机写1个字节数据                                           
    214          //参数说明：  MoudleNum:模块号       
    215          //          DeviceAddr:设备地址    
    216          //          AccessAddr:访问地址
    217          //          Data:要发给从机的1个字节数据  
    218          //函数返回：为0,成功写一个字节;为1,写一个字节失败 
    219          //函数说明: 内部调用 hw_send_signal,hw_wait  
    220          //============================================================================
    221          

   \                                 In section .text, align 2, keep-with-next
    222          uint8 hw_iic_write1(int MoudleNum,uint8 DeviceAddr, uint8 AccessAddr, uint8 Data)
    223          {
   \                     hw_iic_write1:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    224          	//获取i2c模块基址
    225          	I2C_MemMapPtr num = hw_i2c_get_base_address(MoudleNum);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       hw_i2c_get_base_address
   \   00000012   0x4680             MOV      R8,R0
    226          	
    227          	I2C_C1_REG(num) |= 0x10;             //TX = 1,MCU设置为发送模式
   \   00000014   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   00000018   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001C   0xF888 0x0002      STRB     R0,[R8, #+2]
    228              hw_send_signal('S',MoudleNum);             //发送开始信号
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x2053             MOVS     R0,#+83
   \   00000024   0x.... 0x....      BL       hw_send_signal
    229              I2C_D_REG(num) = DeviceAddr & 0xfe;  //发送设备地址,并通知从机接收数据
   \   00000028   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   0000002C   0xF888 0x0004      STRB     R0,[R8, #+4]
    230              if (hw_wait('T',MoudleNum))                //等待一个字节数据传送完成
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x2054             MOVS     R0,#+84
   \   00000034   0x.... 0x....      BL       hw_wait
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??hw_iic_write1_0
    231                  return 1;                        //没有传送成功,写一个字节失败
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE030             B.N      ??hw_iic_write1_1
    232              if (hw_wait('A',MoudleNum))               //等待从机应答信号
   \                     ??hw_iic_write1_0:
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0x2041             MOVS     R0,#+65
   \   00000044   0x.... 0x....      BL       hw_wait
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ.N    ??hw_iic_write1_2
    233                  return 1;                       //没有等到应答信号,写一个字节失败   
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE028             B.N      ??hw_iic_write1_1
    234              I2C_D_REG(num) = AccessAddr;         //发送访问地址
   \                     ??hw_iic_write1_2:
   \   00000050   0xF888 0x6004      STRB     R6,[R8, #+4]
    235              if (hw_wait('T',MoudleNum))               //等待一个字节数据传送完成
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x2054             MOVS     R0,#+84
   \   00000058   0x.... 0x....      BL       hw_wait
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD001             BEQ.N    ??hw_iic_write1_3
    236                  return 1;                       //没有传送成功,写一个字节失败
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xE01E             B.N      ??hw_iic_write1_1
    237              if (hw_wait('A',MoudleNum))               //等待从机应答信号
   \                     ??hw_iic_write1_3:
   \   00000064   0x0021             MOVS     R1,R4
   \   00000066   0x2041             MOVS     R0,#+65
   \   00000068   0x.... 0x....      BL       hw_wait
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ.N    ??hw_iic_write1_4
    238                  return 1;                      //没有等到应答信号,写一个字节失败   
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE016             B.N      ??hw_iic_write1_1
    239              I2C_D_REG(num) = Data;             //写数据
   \                     ??hw_iic_write1_4:
   \   00000074   0xF888 0x7004      STRB     R7,[R8, #+4]
    240              if (hw_wait('T',MoudleNum))              //等待一个字节数据传送完成
   \   00000078   0x0021             MOVS     R1,R4
   \   0000007A   0x2054             MOVS     R0,#+84
   \   0000007C   0x.... 0x....      BL       hw_wait
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??hw_iic_write1_5
    241                  return 1;                      //没有传送成功,写一个字节失败
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xE00C             B.N      ??hw_iic_write1_1
    242              if (hw_wait('A',MoudleNum))              //等待从机应答信号
   \                     ??hw_iic_write1_5:
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0x2041             MOVS     R0,#+65
   \   0000008C   0x.... 0x....      BL       hw_wait
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD001             BEQ.N    ??hw_iic_write1_6
    243                  return 1;                      //没有等到应答信号,写一个字节失败   
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xE004             B.N      ??hw_iic_write1_1
    244              hw_send_signal('O',MoudleNum);           //发送停止信号
   \                     ??hw_iic_write1_6:
   \   00000098   0x0021             MOVS     R1,R4
   \   0000009A   0x204F             MOVS     R0,#+79
   \   0000009C   0x.... 0x....      BL       hw_send_signal
    245              return 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??hw_iic_write1_1:
   \   000000A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    246          }
    247          
    248          
    249          //============================================================================
    250          //函数名称：hw_iic_readn                                                        
    251          //功能概要： 从从机读N个字节数据                                             
    252          //参数说明：  MoudleNum:模块号       
    253          //          DeviceAddr:设备地址    
    254          //          AccessAddr:访问地址
    255          //          Data:读出数据的缓冲区
    256          //          N:从从机读的字节个数 
    257          //函数返回： 为0,成功读N个字节;为1,读N个字节失败  
    258          //函数说明: 内部调用hw_iic_read1  
    259          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    260          uint8 hw_iic_readn(int MoudleNum,uint8 DeviceAddr, uint8 AccessAddr, uint8 Data[], uint8 N)
    261          {
   \                     hw_iic_readn:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    262              uint16 i, j;
    263              for (i = 0;i < N;i++)
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
   \   00000012   0xE001             B.N      ??hw_iic_readn_0
   \                     ??hw_iic_readn_1:
   \   00000014   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_iic_readn_0:
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x4581             CMP      R9,R0
   \   00000024   0xD216             BCS.N    ??hw_iic_readn_2
    264              {
    265                  for(j = 0;j <15*40 ;j++); //最小延时(发送的每个字节之间要有时间间隔)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??hw_iic_readn_3
   \                     ??hw_iic_readn_4:
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??hw_iic_readn_3:
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0xF5B0 0x7F16      CMP      R0,#+600
   \   00000032   0xD3FA             BCC.N    ??hw_iic_readn_4
    266                  if (hw_iic_read1(MoudleNum,DeviceAddr, AccessAddr + i, &Data[i]))  
   \   00000034   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   0xEB19 0x0308      ADDS     R3,R9,R8
   \   0000003C   0xEB19 0x0207      ADDS     R2,R9,R7
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0031             MOVS     R1,R6
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       hw_iic_read1
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD0E1             BEQ.N    ??hw_iic_readn_1
    267                      return 1;             //其中一个字节没有接收到,返回失败标志:1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE007             B.N      ??hw_iic_readn_5
    268              }
    269              if (i >= N)
   \                     ??hw_iic_readn_2:
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x45A1             CMP      R9,R4
   \   0000005E   0xD301             BCC.N    ??hw_iic_readn_6
    270                  return 0;                 //成功接收N个数据,返回成功标志:0
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE7FF             B.N      ??hw_iic_readn_5
    271          }
   \                     ??hw_iic_readn_6:
   \                     ??hw_iic_readn_5:
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    272          
    273          
    274          //============================================================================
    275          //函数名称：hw_iic_writen                                                        
    276          //功能概要： 向从机写N个字节数据                                              
    277          //参数说明：  MoudleNum:模块号       
    278          //          DeviceAddr:设备地址    
    279          //          AccessAddr:访问地址
    280          //          Data:要写入的数据  
    281          //          N:从从机读的字节个数 
    282          //函数返回： 为0,成功写N个字节;为1,写N个字节失败
    283          //函数说明: 内部调用hw_iic_write1   
    284          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    285          uint8 hw_iic_writen(int MoudleNum,uint8 DeviceAddr, uint8 AccessAddr,uint8 Data[], uint8 N)
    286          {
   \                     hw_iic_writen:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    287              uint16 i, j;
    288              for (i = 0;i < N;i++)
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
   \   00000012   0xE001             B.N      ??hw_iic_writen_0
   \                     ??hw_iic_writen_1:
   \   00000014   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_iic_writen_0:
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x4581             CMP      R9,R0
   \   00000024   0xD216             BCS.N    ??hw_iic_writen_2
    289              {
    290                  for(j = 0;j < 15*40;j++); //最小延时(发送的每个字节之间要有时间间隔)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??hw_iic_writen_3
   \                     ??hw_iic_writen_4:
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??hw_iic_writen_3:
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0xF5B0 0x7F16      CMP      R0,#+600
   \   00000032   0xD3FA             BCC.N    ??hw_iic_writen_4
    291                  if (hw_iic_write1(MoudleNum,DeviceAddr, AccessAddr + i, Data[i]))
   \   00000034   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   0xF819 0x3008      LDRB     R3,[R9, R8]
   \   0000003C   0xEB19 0x0207      ADDS     R2,R9,R7
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0031             MOVS     R1,R6
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       hw_iic_write1
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD0E1             BEQ.N    ??hw_iic_writen_1
    292                      return 1;            //其中一个字节没有发送出去,返回失败标志:1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE007             B.N      ??hw_iic_writen_5
    293              }
    294              if (i >= N)
   \                     ??hw_iic_writen_2:
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x45A1             CMP      R9,R4
   \   0000005E   0xD301             BCC.N    ??hw_iic_writen_6
    295                  return 0;                //成功发送N个数据,返回成功标志:0
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE7FF             B.N      ??hw_iic_writen_5
    296          }
   \                     ??hw_iic_writen_6:
   \                     ??hw_iic_writen_5:
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    297          //============================================================================
    298          //函数名称：hw_i2c_get_base_address                                                        
    299          //功能概要：获取i2c模块的基址                                                
    300          //参数说明：i2cNO:i2c模块号      
    301          //函数返回：i2c模块的基址值                                                                  
    302          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    303          I2C_MemMapPtr hw_i2c_get_base_address(int i2cNO)
    304          {
    305          	switch(i2cNO)
   \                     hw_i2c_get_base_address:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ.N    ??hw_i2c_get_base_address_0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD002             BEQ.N    ??hw_i2c_get_base_address_1
   \   00000008   0xE003             B.N      ??hw_i2c_get_base_address_2
    306          	{
    307          	case 0:
    308          		return I2C0_BASE_PTR;
   \                     ??hw_i2c_get_base_address_0:
   \   0000000A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000000C   0xE001             B.N      ??hw_i2c_get_base_address_3
    309          		break;
    310          	case 1:
    311          		return I2C1_BASE_PTR;
   \                     ??hw_i2c_get_base_address_1:
   \   0000000E   0x....             LDR.N    R0,??DataTable2_10  ;; 0x40067000
   \   00000010   0xE7FF             B.N      ??hw_i2c_get_base_address_3
    312          		break;
    313          	
    314          	}
    315          }
   \                     ??hw_i2c_get_base_address_2:
   \                     ??hw_i2c_get_base_address_3:
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40066001         DC32     0x40066001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40066002         DC32     0x40066002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x4004B028         DC32     0x4004b028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x4004B02C         DC32     0x4004b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40067001         DC32     0x40067001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40067002         DC32     0x40067002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40067000         DC32     0x40067000
    316          #endif 

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  hw_i2c_get_base_address
        8  hw_i2c_init
              8 -> hw_i2c_get_base_address
       24  hw_iic_read1
             24 -> hw_i2c_get_base_address
             24 -> hw_send_signal
             24 -> hw_wait
       32  hw_iic_readn
             32 -> hw_iic_read1
       24  hw_iic_write1
             24 -> hw_i2c_get_base_address
             24 -> hw_send_signal
             24 -> hw_wait
       32  hw_iic_writen
             32 -> hw_iic_write1
        8  hw_send_signal
              8 -> hw_i2c_get_base_address
        8  hw_wait
              8 -> hw_i2c_get_base_address


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      20  hw_i2c_get_base_address
     112  hw_i2c_init
     202  hw_iic_read1
     104  hw_iic_readn
     166  hw_iic_write1
     104  hw_iic_writen
     102  hw_send_signal
      82  hw_wait

 
 936 bytes in section .text
 
 936 bytes of CODE memory

Errors: none
Warnings: 4
